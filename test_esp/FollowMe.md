## 로봇 제어 앱 개발 프로젝트 명세서 (수정 및 보완 버전)

아래는 기존에 제시해주신 프롬프트를 바탕으로, 실제 개발 과정에서의 명확성을 높이고 안정성과 확장성을 강화하기 위해 수정 및 보완한 프로젝트 명세서입니다.

---

### **1. 개발 환경**

*   **앱 프레임워크:** Flutter (모바일 & 웹 동시 지원)
*   **상태 관리:** Riverpod (데이터 흐름 및 상태의 체계적 관리를 위함)
*   **로봇 연결 방식:** WiFi (TCP) / Bluetooth (옵션)
*   **개발 언어:** Dart (앱), Arduino (로봇)

### **2. 하드웨어 구조**

*   **로봇 형태:** 2-Wheels 구동 로봇 (제자리 회전 가능)
*   **구동부:** L298 모터 드라이버 (좌측 모터, 우측 모터 제어)
*   **제어 MCU:** ESP32 (ESP32-CAM 포함)
*   **추가 장치:** OSD (On-Screen Display) 모듈
    *   **역할:** 로봇의 IP 주소, WiFi 연결 상태, 현재 모터 속도 등 주요 상태 정보를 물리적 디스플레이에 실시간으로 표시

### **3. 조이스틱 UI**

*   **형태:** 원형 조이스틱
*   **위치:** 앱 화면 좌측 하단에 고정
*   **입력 범위:** X, Y 좌표 (각 축 -255 ~ +255)
*   **출력 변환 방식:** **Mix-steering 로직**을 적용하여 조이스틱의 X(좌/우), Y(전/후진) 좌표 값을 좌측 및 우측 모터 속도로 정밀하게 매핑 (상세 변환 공식은 별도 정의)
*   **특수 기능:**
    *   조이스틱에서 손을 떼면 즉시 `{"Left Motor": 0, "Right Motor": 0}` 전송 (즉시 정지)
    *   조이스틱 UI는 실시간 동영상 스트리밍 화면 위에 반투명 오버레이로 표시

### **4. 데이터 전송**

*   **통신 프로토콜:** TCP
*   **주행 패킷 구조:**
    *   향후 기능 확장을 고려하여 **패킷 타입('type') 필드**를 포함하는 JSON 구조 사용
    *   **예시:** `{"type": "drive", "data": {"Left Motor": 200, "Right Motor": -200}}`
*   **프로토콜 신뢰성 확보 (선택 사항):**
    *   안정적인 통신을 위해 패킷의 시작/끝을 알리는 **SOF/EOF(Start/End of Frame) 바이트** 또는 데이터 오류 검증을 위한 **Checksum** 추가를 고려

### **5. 로봇 측 요구사항**

*   **수신 방식:** ESP32에 TCP 서버를 구축하여 앱의 연결 요청을 수신하고, 수신된 JSON 데이터를 파싱하여 L298 드라이버 제어
*   **변환 로직:** 앱으로부터 받은 좌/우 모터 속도 값을 PWM 신호로 변환하여 모터에 출력
*   **안전 장치:**
    *   **입력 없음:** 일정 시간(예: 500ms) 동안 새로운 데이터 수신이 없을 경우 모터를 0,0으로 자동 정지
    *   **연결 끊김:** TCP 연결이 끊기는 즉시 모터를 정지하고, 상태 표시 LED를 점등하여 시각적으로 알림
*   **참조 코드:**
    *   제공된 `08_camera` 폴더 내 아두이노 파일을 **참조**하되, 기존 파일을 수정하지 않고 본 프로젝트 명세에 맞는 별도의 아두이노 제어 코드를 신규 생성

### **6. 성능 & 안정성**

*   **입력 주기:** Polling 방식이 아닌, 사용자의 조이스틱 **이벤트가 발생할 때만 즉시 전송**하여 불필요한 네트워크 트래픽 최소화
*   **연결 끊김 처리:**
    *   연결이 끊기면 앱은 즉시 모터 정지(`0,0`) 명령 재전송 시도
    *   **자동 리커넥팅 시도** (예: 5초 간격으로 3회 시도) 후, 실패 시 사용자에게 연결 실패 알림
*   **상태 표시:** 연결 상태(연결 중, 연결 성공, 연결 끊김)를 앱 UI와 로봇의 상태 LED로 명확히 표시
*   **지연시간 최소화 전략:**
    *   데이터 패킷 구조를 최적화하여 크기 최소화
    *   ESP32 내부의 데이터 파싱 및 모터 제어 로직 처리 시간 단축
    *   스트리밍의 해상도/프레임을 네트워크 환경에 맞게 최적화 (예: 320x240, 15fps)

### **7. 확장 기능**

*   **카메라 스트리밍:** ESP32-CAM의 MJPEG 스트림을 Flutter/Web 앱에서 전체화면으로 수신 및 출력
*   **AR/HUD 표시:**
    *   스트리밍 화면 위에 다양한 정보를 오버레이하여 표시
    *   **표시 정보:** 현재 좌/우 모터 속도, 앱-로봇 간 연결 상태(Ping), 통신 지연시간, 로봇 배터리 전압(추후 확장) 등
*   **웹 지원:**
    *   Flutter Web으로 빌드하여 브라우저에서 모바일 앱과 동일한 조이스틱 제어 및 스트리밍 기능 지원
    *   **구현 방식:** **WebSocket**을 우선적으로 사용하여 'WebSocket → ESP32 TCP 브리지 서버' 구조로 구현

### **8. ESP 연결 방법**

*   **WiFi 설정:**
    *   ESP32는 사전에 코드에 지정된 SSID/비밀번호를 통해 로컬 AP에 접속
    *   **(편의 기능)** **mDNS 프로토콜**을 사용하여 앱이 네트워크 내에서 'robot.local'과 같은 호스트 이름으로 ESP32를 자동으로 발견하는 기능 구현
*   **TCP 서버 실행 (ESP32):**
    *   지정된 포트(예: 8888)에서 앱의 TCP 클라이언트 접속을 대기하고, 연결 시 양방향 통신 채널 수립
*   **스트리밍 URL 접근:**
    *   ESP32-CAM이 제공하는 MJPEG URL(예: `http://<ESP32-IP>:81/stream`)을 Flutter/Web의 영상 위젯에서 로드하여 전체화면으로 출력
*   **연결 모드:**
    *   **모바일 앱:** 동일 WiFi 네트워크 내에서 ESP32의 IP(또는 mDNS 호스트 이름)와 포트로 TCP 직접 연결
    *   **웹 앱:** 브라우저(WebSocket) ↔ 브리지 서버 ↔ ESP32(TCP) 구조로 데이터 중계